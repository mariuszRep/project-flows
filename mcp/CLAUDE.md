# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

This is a TypeScript implementation of the MCP (Model Context Protocol) server with SSE (Server-Sent Events) support for multiple concurrent clients. The project provides task creation and planning functionality through multiple tools with shared database persistence.

## Architecture

- **Main Server**: `src/index.ts` - The primary MCP server implementation in TypeScript
- **Schema Configuration**: `schema_properties.json` - Defines dynamic schema properties for task creation
- **Build Output**: `dist/` - Compiled JavaScript output (generated by TypeScript compiler)

### Core Components

- **SSE Multi-Client Support**: Express.js server with SSE transport for concurrent client connections
- **Shared Database**: PostgreSQL database service shared across all client sessions with audit trail
- **Session Management**: Individual MCP server instances per client with session tracking
- **Client Identification**: Automatic client detection for audit tracking (windsurf, claude-desktop, etc.)
- Tool registration system with dynamic schema loading from database/JSON configuration
- Dependency validation and execution ordering for task properties
- Markdown output formatting for task plans

## Development Commands

### Environment Setup
```bash
# Install dependencies
npm install

# Build the project
npm run build

# Run the SSE server (HTTP server on port 3001)
npm start

# Development mode with auto-reload
npm run dev

# Clean build artifacts
npm run clean
```

### Dependencies
- Node.js (ES2022 compatible)
- TypeScript 5.x
- @modelcontextprotocol/sdk - MCP SDK for TypeScript
- Express.js 5.x - Web server for SSE endpoints
- CORS - Cross-origin resource sharing support
- PostgreSQL (pg) - Database client
- Zod - Schema validation
- tsx - TypeScript execution for development

## Key Implementation Details

- The server provides these tools:
  - Task Tools: `create_task`, `update_task`
  - Object Tools: `get_object`, `delete_object`, `list_objects`
  - Workflow Tools: `execute_task` (guided execution), `initiate_project` (analyze project and generate tasks)
- Dynamic properties are loaded from `schema_properties.json` with execution order and dependency management
- Properties include Research (depends on Summary) and Items (depends on Summary and Research)
- Output is formatted as structured markdown with sections for each property
- Server runs over HTTP with SSE (Server-Sent Events) for real-time communication
- Multiple clients can connect simultaneously, sharing the same database
- Each client gets its own MCP server instance with session management
- Default port: 3001 (configurable via PORT environment variable)
- **Audit Trail**: All database operations track `created_by` and `updated_by` using client identification

## Client Configuration

The server automatically identifies MCP clients for audit tracking through multiple methods:

### Method 1: Query Parameters (Recommended)
```json
{
  "mcpServers": {
    "project-flows": {
      "serverUrl": "http://localhost:3001/sse?client=windsurf"
    }
  }
}
```

### Method 2: HTTP Headers
```json
{
  "mcpServers": {
    "project-flows": {
      "serverUrl": "http://localhost:3001/sse",
      "headers": {
        "X-MCP-Client": "windsurf"
      }
    }
  }
}
```

### Method 3: User-Agent Detection (Automatic)
The server automatically detects these clients from User-Agent strings:
- `windsurf` - Windsurf IDE
- `claude-desktop` - Claude Desktop App
- `cursor` - Cursor IDE
- `vscode` - VS Code
- `cline` - Cline extension

### Audit Trail
All tasks and blocks in the database include audit columns:
- `created_at` / `updated_at`: Automatic timestamps
- `created_by` / `updated_by`: Client identifier (e.g., "windsurf", "claude-desktop")
- `stage`: Task workflow stage ('draft', 'backlog', 'doing', 'review', 'completed')

This enables tracking which MCP client created or modified each record and task workflow progression.

## Tool Usage Examples

### create_task
Create a task:

```json
{
  "name": "create_task",
  "arguments": {
    "Title": "Implement user authentication system",
    "Description": "Add secure login/logout functionality with session management",
    "Items": "- Set up OAuth 2.0 configuration\n- Implement JWT token generation and validation",
    "stage": "backlog",
    "parent_id": 2
  }
}
```

### update_task
Update fields of an existing task by task ID:

```json
{
  "name": "update_task",
  "arguments": {
    "task_id": 1,
    "Title": "Enhanced user authentication system",
    "stage": "doing"
  }
}
```

### get_object
Retrieve a complete object by numeric ID:

```json
{ "name": "get_object", "arguments": { "object_id": 1 } }
```

### list_objects
List objects with optional filters:

```json
{ "name": "list_objects", "arguments": { "template_id": 1 } }
{ "name": "list_objects", "arguments": { "template_id": 1, "stage": "backlog" } }
```

### delete_object
Delete object by ID:

```json
{ "name": "delete_object", "arguments": { "object_id": 1 } }
```

### execute_task
Orchestrates task execution by loading task and project context, then providing guided execution with real-time progress tracking. **Important**: This tool automatically moves the task stage from 'backlog' → 'doing' → 'review' upon successful completion.

#### Basic usage:
```json
{
  "name": "execute_task",
  "arguments": {
    "task_id": 1
  }
}
```

#### Task ID validation:
- ✅ Valid: `{"task_id": 1}` (numeric ID ≥ 1)
- ❌ Invalid: `{}` (missing task_id)
- ❌ Invalid: `{"task_id": "1"}` (string ID)
- ❌ Invalid: `{"task_id": 0}` (ID must be ≥ 1)

#### Workflow behavior:
1. **Context Loading**: Loads task and project context from database
2. **Stage Transition**: Moves task from current stage to 'doing'
3. **Execution Guidance**: Returns structured execution context with branch creation guidance
4. **Completion**: Automatically moves task to 'review' stage upon successful execution
5. **Notifications**: Emits database change notifications for real-time UI updates

#### Output format:
Returns JSON with execution context including:
- `task_id`: The task being executed
- `status`: Current execution status
- `task_context`: Complete task data with all properties
- `project_context`: Parent project data (if applicable)
- `instructions`: Step-by-step execution guidance
- `branch_naming_guidelines`: Git branch naming conventions

#### Stage transitions:
- **Initial**: Any stage → 'doing' (when execution starts)
- **Final**: 'doing' → 'review' (when execution completes successfully)
- **Error handling**: If stage update fails, execution context is still returned with logged error

#### Error handling:
- **Missing task**: Returns `Error: Task with ID [id] not found.`
- **Invalid ID**: Returns `Error: Valid numeric task_id is required for execution.`
- **Stage update failure**: Logs error but continues with execution context

### initiate_project
Analyzes a project and automatically generates appropriate tasks based on project context and complexity. This tool dynamically determines task structure without hardcoded properties, making it adaptable to different project types and requirements.

#### Basic usage:
```json
{
  "name": "initiate_project",
  "arguments": {
    "project_id": 1
  }
}
```

#### Advanced usage with options:
```json
{
  "name": "initiate_project",
  "arguments": {
    "project_id": 1,
    "analysis_depth": "comprehensive",
    "max_tasks": 10
  }
}
```

#### Parameter validation:
- ✅ Valid: `{"project_id": 1}` (numeric ID ≥ 1)
- ✅ Valid: `{"project_id": 1, "analysis_depth": "standard"}` (with optional depth)
- ✅ Valid: `{"project_id": 1, "max_tasks": 5}` (with task limit)
- ❌ Invalid: `{}` (missing project_id)
- ❌ Invalid: `{"project_id": "1"}` (string ID)
- ❌ Invalid: `{"project_id": 0}` (ID must be ≥ 1)

#### Analysis depth options:
- **`basic`**: Minimal task breakdown, focuses on core functionality
- **`standard`** (default): Balanced approach with moderate task detail
- **`comprehensive`**: Detailed task breakdown with extensive planning

#### Workflow behavior:
1. **Project Loading**: Retrieves project context using `get_object` tool
2. **Schema Discovery**: Dynamically loads project and task property schemas using `list_properties`
3. **Analysis Generation**: Creates analysis prompt based on available properties
4. **Task Generation**: Determines appropriate tasks based on project complexity
5. **Task Creation**: Creates tasks using `create_task` with proper relationships
6. **Report Generation**: Returns comprehensive analysis report with created tasks

#### Output format:
Returns JSON with analysis results including:
```json
{
  "project": {
    "id": 1,
    "title": "Project Title"
  },
  "analysis": {
    "depth": "standard",
    "taskCount": 5,
    "completionStatus": "success"
  },
  "tasks": [
    {
      "id": 10,
      "title": "Task Title",
      "stage": "backlog"
    }
  ],
  "summary": "Successfully initiated project and created 5 tasks."
}
```

#### Dynamic property handling:
- Automatically discovers available project and task properties from database schema
- Filters properties based on schema availability to avoid hardcoded assumptions
- Generates analysis prompts using only available properties
- Creates tasks with properties that exist in the current schema

#### Error handling:
- **Missing project**: Returns `{"error": "Project with ID [id] not found."}`
- **Invalid ID**: Returns `{"error": "Valid numeric project_id is required for analysis."}`
- **Schema loading failure**: Returns `{"error": "Failed to load project/task property schema."}`
- **Task creation failure**: Continues with remaining tasks, logs individual failures

- Uses `get_object` to retrieve project context
- Uses `list_properties` to discover available schemas dynamically
- Uses `create_task` to generate tasks with proper parent relationships
- All created tasks are automatically set to 'backlog' stage
- Tasks inherit project ID as parent_id for proper hierarchy

#### Best practices:
- Run this tool after creating a new project to automatically populate it with tasks
- Use `analysis_depth: "comprehensive"` for complex projects requiring detailed planning
- Use `max_tasks` parameter to limit task generation for large projects
- Generated tasks can be further refined using `update_task` after creation
- Use `execute_task` on generated tasks to begin implementation workflow

## Build Process

The project uses TypeScript compilation:
- Source files in `src/` are compiled to `dist/`
- ES modules with Node.js compatibility
- Source maps and declarations generated for debugging
- Strict TypeScript configuration for type safety
