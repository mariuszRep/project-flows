import { useState, useEffect, useMemo } from 'react';
import { createPortal } from 'react-dom';
import { Card } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { AutoTextarea } from '@/components/ui/auto-textarea';
import { Checkbox } from '@/components/ui/checkbox';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { X, Save, Plus, Trash2, Loader2, Settings } from 'lucide-react';
import { Node } from 'reactflow';
import { useToast } from '@/hooks/use-toast';
import { useMCP } from '@/contexts/MCPContext';

interface WorkflowEditModalProps {
  isOpen: boolean;
  onClose: () => void;
  workflowId: number | null;
  workflowName: string;
  workflowDescription: string;
  nodes: Node[];
  onSave: () => void;
}

// Workflow parameter interface (maps to property in database)
interface WorkflowParameter {
  id?: number; // Property ID from database
  key: string; // Property key (parameter name)
  type: string;
  description: string;
  required?: boolean;
  default?: string;
  source_node?: string;
  source_property?: string;
}

interface DiscoveredParameter {
  propertyKey: string;
  propertyDescription: string;
  templateId: number;
  templateName: string;
  nodeId: string;
  nodeLabel: string;
}

export function WorkflowEditModal({
  isOpen,
  onClose,
  workflowId,
  workflowName: initialName,
  workflowDescription: initialDescription,
  nodes,
  onSave,
}: WorkflowEditModalProps) {
  const { toast } = useToast();
  const { callTool, isConnected } = useMCP();
  const [name, setName] = useState('');
  const [description, setDescription] = useState('');
  const [toolName, setToolName] = useState('');
  const [parameters, setParameters] = useState<WorkflowParameter[]>([]);
  const [isSaving, setIsSaving] = useState(false);
  const [isDiscovering, setIsDiscovering] = useState(false);
  const [discoveredParameters, setDiscoveredParameters] = useState<DiscoveredParameter[]>([]);

  // Description edit modal state
  const [editingParamIndex, setEditingParamIndex] = useState<number | null>(null);
  const [editingDescription, setEditingDescription] = useState('');

  // Initialize form data and load parameters when modal opens
  useEffect(() => {
    if (isOpen && workflowId && callTool) {
      const loadWorkflowSettings = async () => {
        try {
          // Load template metadata
          const result = await callTool('get_template', { template_id: workflowId });
          if (result && result.content && result.content[0]) {
            const templateData = JSON.parse(result.content[0].text);
            const metadata = templateData.metadata || {};

            setName(templateData.name || '');
            setDescription(templateData.description || '');
            setToolName(metadata.mcp_tool_name || templateData.name.toLowerCase().replace(/\s+/g, '_'));
          }

          // Load parameters from properties table
          const propsResult = await callTool('list_properties', { template_id: workflowId });
          if (propsResult && propsResult.content && propsResult.content[0]) {
            const propsText = propsResult.content[0].text;
            if (!propsText.includes('No properties found')) {
              const properties = JSON.parse(propsText);
              const params = Array.isArray(properties)
                ? properties
                    .filter((p: any) => p.step_type === 'property')
                    .map((p: any) => ({
                      id: p.id,
                      key: p.key,
                      type: p.type,
                      description: p.description,
                      required: p.step_config?.required || false,
                      default: p.step_config?.default || '',
                      source_node: p.step_config?.source_node,
                      source_property: p.step_config?.source_property,
                    }))
                : [];
              setParameters(params);
            } else {
              setParameters([]);
            }
          }
        } catch (error) {
          console.error('Error loading workflow settings:', error);
          // Fallback to props
          setName(initialName);
          setDescription(initialDescription);
          setToolName(initialName.toLowerCase().replace(/\s+/g, '_'));
          setParameters([]);
        }
      };

      loadWorkflowSettings();
    }
  }, [isOpen, workflowId, callTool, initialName, initialDescription]);

  // Discover parameters from nodes
  useEffect(() => {
    const discoverParameters = async () => {
      if (!isOpen || !isConnected || !callTool) {
        return;
      }

      setIsDiscovering(true);
      const discovered: DiscoveredParameter[] = [];

      try {
        // Find all create_object nodes
        const createObjectNodes = nodes.filter(node => node.type === 'create_object');

        for (const node of createObjectNodes) {
          const templateId = node.data.config?.template_id;
          const selectedProperties = node.data.config?.properties || {};

          if (!templateId || Object.keys(selectedProperties).length === 0) {
            continue;
          }

          // Load template name
          const templatesResult = await callTool('list_templates', {});
          if (!templatesResult || !templatesResult.content || !templatesResult.content[0]) {
            continue;
          }

          const templatesText = templatesResult.content[0].text;
          if (templatesText.includes('No templates')) {
            continue;
          }

          const templates = JSON.parse(templatesText);
          const template = Array.isArray(templates)
            ? templates.find((t: any) => t.id === templateId)
            : null;

          if (!template) {
            continue;
          }

          // Load properties for this template
          const propsResult = await callTool('list_properties', { template_id: templateId });
          if (!propsResult || !propsResult.content || !propsResult.content[0]) {
            continue;
          }

          const propsText = propsResult.content[0].text;
          if (propsText.includes('No properties found')) {
            continue;
          }

          const properties = JSON.parse(propsText);
          const templateProperties = Array.isArray(properties)
            ? properties.filter((p: any) => p.step_type === 'property')
            : [];

          // Add each selected property to discovered list
          for (const propKey of Object.keys(selectedProperties)) {
            if (selectedProperties[propKey] === true) {
              const prop = templateProperties.find((p: any) => p.key === propKey);
              if (prop) {
                discovered.push({
                  propertyKey: prop.key,
                  propertyDescription: prop.description || `Value for ${prop.key}`,
                  templateId: templateId,
                  templateName: template.name,
                  nodeId: node.id,
                  nodeLabel: node.data.label || node.id,
                });
              }
            }
          }
        }

        setDiscoveredParameters(discovered);
      } catch (error) {
        console.error('Error discovering parameters:', error);
        setDiscoveredParameters([]);
      } finally {
        setIsDiscovering(false);
      }
    };

    discoverParameters();
  }, [isOpen, nodes, isConnected, callTool]);

  // Group discovered parameters by property key
  const groupedDiscovered = useMemo(() => {
    const grouped = new Map<string, DiscoveredParameter[]>();
    for (const param of discoveredParameters) {
      const key = param.propertyKey;
      if (!grouped.has(key)) {
        grouped.set(key, []);
      }
      grouped.get(key)!.push(param);
    }
    return grouped;
  }, [discoveredParameters]);

  // Load properties for a specific template
  const loadPropertiesForTemplate = async (templateId: number) => {
    if (propertiesByTemplate.has(templateId) || !callTool) {
      return;
    }

    setIsLoadingProperties(prev => new Set(prev).add(templateId));

    try {
      const result = await callTool('list_properties', { template_id: templateId });
      if (result && result.content && result.content[0]) {
        const text = result.content[0].text;
        if (!text.includes('No properties found')) {
          const properties = JSON.parse(text);
          const propertyList = Array.isArray(properties)
            ? properties.filter((p: any) => p.step_type === 'property')
            : [];
          setPropertiesByTemplate(prev => new Map(prev).set(templateId, propertyList));
        } else {
          setPropertiesByTemplate(prev => new Map(prev).set(templateId, []));
        }
      }
    } catch (error) {
      console.error('Error loading properties:', error);
      setPropertiesByTemplate(prev => new Map(prev).set(templateId, []));
    } finally {
      setIsLoadingProperties(prev => {
        const next = new Set(prev);
        next.delete(templateId);
        return next;
      });
    }
  };

  const resetNewParameterForm = () => {
    setNewParamName('');
    setNewParamType('string');
    setNewParamRequired(false);
    setNewParamDescription('');
    setNewParamDefault('');
    setSelectedTemplateId(null);
    setSelectedPropertyKey('');
    setParameterSource('custom');
    setShowAddParameterForm(false);
  };

  const addCustomParameter = () => {
    const paramName = newParamName.trim();

    if (!paramName) {
      toast({
        title: "Validation Error",
        description: "Parameter name is required",
        variant: "destructive",
      });
      return;
    }

    // Check if already exists
    if (parameters.some(p => p.name === paramName)) {
      toast({
        title: "Parameter Already Exists",
        description: `Parameter "${paramName}" is already in the workflow.`,
        variant: "destructive",
      });
      return;
    }

    const newParam: CustomParameter = {
      parameter_source: 'custom',
      name: paramName,
      type: newParamType,
      required: newParamRequired,
      description: newParamDescription.trim(),
      default: newParamDefault.trim() || undefined,
    };

    setParameters([...parameters, newParam]);
    resetNewParameterForm();
    toast({
      title: "Parameter Added",
      description: `Custom parameter "${paramName}" has been added.`,
    });
  };

  const addTemplateParameter = () => {
    if (!selectedTemplateId || !selectedPropertyKey) {
      toast({
        title: "Validation Error",
        description: "Please select both a template and a property",
        variant: "destructive",
      });
      return;
    }

    const template = templates.find(t => t.id === selectedTemplateId);
    const properties = propertiesByTemplate.get(selectedTemplateId) || [];
    const property = properties.find((p: any) => p.key === selectedPropertyKey);

    if (!template || !property) {
      toast({
        title: "Error",
        description: "Selected template or property not found",
        variant: "destructive",
      });
      return;
    }

    const paramName = newParamName.trim() || selectedPropertyKey.toLowerCase().replace(/\s+/g, '_');

    // Check if already exists
    if (parameters.some(p => p.name === paramName)) {
      toast({
        title: "Parameter Already Exists",
        description: `Parameter "${paramName}" is already in the workflow.`,
        variant: "destructive",
      });
      return;
    }

    const newParam: TemplateParameter = {
      parameter_source: 'template',
      name: paramName,
      type: newParamType,
      required: newParamRequired,
      description: newParamDescription.trim() || property.description || `Value for ${property.key}`,
      default: newParamDefault.trim() || undefined,
      template_id: selectedTemplateId,
      template_name: template.name,
      property_key: selectedPropertyKey,
    };

    setParameters([...parameters, newParam]);
    resetNewParameterForm();
    toast({
      title: "Parameter Added",
      description: `Template parameter "${paramName}" has been added from ${template.name}.`,
    });
  };

  const addParameter = (discoveredParam?: DiscoveredParameter) => {
    if (discoveredParam) {
      // Add from discovered parameters
      const paramName = discoveredParam.propertyKey.toLowerCase().replace(/\s+/g, '_');

      // Check if already exists
      if (parameters.some(p => p.name === paramName)) {
        toast({
          title: "Parameter Already Exists",
          description: `Parameter "${paramName}" is already in the workflow.`,
          variant: "destructive",
        });
        return;
      }

      const newParam: CustomParameter = {
        parameter_source: 'custom',
        name: paramName,
        type: 'string',
        required: discoveredParam.propertyKey === 'Title' || discoveredParam.propertyKey === 'Description',
        description: discoveredParam.propertyDescription,
        source_node: discoveredParam.nodeId,
        source_property: discoveredParam.propertyKey,
      };

      setParameters([...parameters, newParam]);
    } else {
      // Show add parameter form
      setShowAddParameterForm(true);
    }
  };

  const removeParameter = (index: number) => {
    setParameters(parameters.filter((_, i) => i !== index));
  };

  const updateParameter = (index: number, field: keyof WorkflowParameter, value: any) => {
    const updated = [...parameters];
    updated[index] = { ...updated[index], [field]: value };
    setParameters(updated);
  };

  const validateForm = (): boolean => {
    if (!name.trim()) {
      toast({
        title: "Validation Error",
        description: "Workflow name is required",
        variant: "destructive",
      });
      return false;
    }

    if (!toolName.trim()) {
      toast({
        title: "Validation Error",
        description: "Tool name is required",
        variant: "destructive",
      });
      return false;
    }

    // Validate tool name format (lowercase, underscores only)
    if (!/^[a-z][a-z0-9_]*$/.test(toolName)) {
      toast({
        title: "Validation Error",
        description: "Tool name must start with a letter and contain only lowercase letters, numbers, and underscores",
        variant: "destructive",
      });
      return false;
    }

    // Validate parameter names are unique across both types
    const paramNames = parameters.map(p => p.name.trim()).filter(n => n);
    const uniqueNames = new Set(paramNames);
    if (paramNames.length !== uniqueNames.size) {
      toast({
        title: "Validation Error",
        description: "Parameter names must be unique across all parameters",
        variant: "destructive",
      });
      return false;
    }

    // Validate all parameters have names
    for (const param of parameters) {
      if (!param.name.trim()) {
        toast({
          title: "Validation Error",
          description: "All parameters must have a name",
          variant: "destructive",
        });
        return false;
      }

      // Validate template-based parameters have required fields
      if (isTemplateParameter(param)) {
        if (!param.template_id || !param.property_key) {
          toast({
            title: "Validation Error",
            description: "Template parameters must have valid template and property references",
            variant: "destructive",
          });
          return false;
        }
      }
    }

    // Check for duplicate template+property combinations
    const templateParams = parameters.filter(isTemplateParameter);
    const templatePropertyPairs = templateParams.map(p => `${p.template_id}-${p.property_key}`);
    const uniquePairs = new Set(templatePropertyPairs);
    if (templatePropertyPairs.length !== uniquePairs.size) {
      toast({
        title: "Validation Error",
        description: "Cannot have duplicate template-property combinations",
        variant: "destructive",
      });
      return false;
    }

    return true;
  };

  const handleSave = async () => {
    if (!validateForm() || !workflowId || !callTool) {
      return;
    }

    setIsSaving(true);
    try {
      // Get current template metadata
      const result = await callTool('get_template', { template_id: workflowId });
      if (!result || !result.content || !result.content[0]) {
        throw new Error('Failed to fetch template');
      }

      const templateData = JSON.parse(result.content[0].text);
      const currentMetadata = templateData.metadata || {};

      // Update template with new settings
      await callTool('update_template', {
        template_id: workflowId,
        name: name,
        description: description,
        metadata: {
          ...currentMetadata,
          mcp_tool_name: toolName,
          tool_description: description,
          workflow_parameters: parameters,
        }
      });

      toast({
        title: "Workflow Settings Saved",
        description: "Your workflow configuration has been updated successfully.",
      });

      onSave();
      onClose();
    } catch (error) {
      console.error('Error saving workflow settings:', error);
      toast({
        title: "Save Failed",
        description: "Failed to save workflow settings. Please try again.",
        variant: "destructive",
      });
    } finally {
      setIsSaving(false);
    }
  };

  if (!isOpen) {
    return null;
  }

  return createPortal(
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50 overflow-y-auto p-4">
      <Card className="w-full max-w-5xl mx-auto max-h-[90vh] flex flex-col">
        {/* Header */}
        <div className="sticky top-0 bg-background p-6 flex items-center justify-between rounded-t-lg border-b">
          <div className="flex items-center gap-3">
            <Settings className="w-6 h-6 text-primary" />
            <h2 className="text-2xl font-semibold text-foreground">Workflow Settings</h2>
          </div>
          <Button variant="ghost" size="icon" onClick={onClose}>
            <X className="h-4 w-4" />
          </Button>
        </div>

        {/* Content */}
        <div className="flex-1 overflow-y-auto p-6">
          <div className="space-y-6">
            {/* Basic Information */}
            <div className="space-y-4">
              <h3 className="text-lg font-semibold">Basic Information</h3>

              <div>
                <Label className="text-sm">Workflow Name</Label>
                <Input
                  value={name}
                  onChange={(e) => setName(e.target.value)}
                  placeholder="My Workflow"
                  className="mt-1"
                />
              </div>

              <div>
                <Label className="text-sm">Description</Label>
                <AutoTextarea
                  value={description}
                  onChange={(e) => setDescription(e.target.value)}
                  placeholder="Describe what this workflow does..."
                  minRows={3}
                  maxRows={6}
                  className="mt-1"
                />
              </div>

              <div>
                <Label className="text-sm">MCP Tool Name</Label>
                <Input
                  value={toolName}
                  onChange={(e) => setToolName(e.target.value)}
                  placeholder="my_workflow_tool"
                  className="mt-1 font-mono"
                />
                <p className="text-xs text-muted-foreground mt-1">
                  Lowercase letters, numbers, and underscores only. This is how the workflow will be called as an MCP tool.
                </p>
              </div>
            </div>

            {/* Parameters Configuration */}
            <div className="space-y-4">
              <div className="flex items-center justify-between">
                <div>
                  <h3 className="text-lg font-semibold">Workflow Parameters</h3>
                  <p className="text-sm text-muted-foreground">
                    Define input parameters that will be available to all nodes in this workflow.
                  </p>
                </div>
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => addParameter()}
                  className="gap-2"
                >
                  <Plus className="h-4 w-4" />
                  Add Custom Parameter
                </Button>
              </div>

              {/* Add Parameter Form */}
              {showAddParameterForm && (
                <div className="border rounded-lg p-4 bg-background space-y-4">
                  <div className="flex items-center justify-between">
                    <h4 className="font-semibold">Add New Parameter</h4>
                    <Button
                      type="button"
                      variant="ghost"
                      size="sm"
                      onClick={resetNewParameterForm}
                    >
                      <X className="h-4 w-4" />
                    </Button>
                  </div>

                  {/* Parameter Source Tabs */}
                  <div className="flex gap-2 p-1 bg-muted rounded-lg">
                    <button
                      type="button"
                      onClick={() => setParameterSource('custom')}
                      className={`flex-1 px-4 py-2 rounded transition-colors ${
                        parameterSource === 'custom'
                          ? 'bg-background shadow-sm font-medium'
                          : 'hover:bg-background/50'
                      }`}
                    >
                      🔧 Custom
                    </button>
                    <button
                      type="button"
                      onClick={() => setParameterSource('template')}
                      className={`flex-1 px-4 py-2 rounded transition-colors ${
                        parameterSource === 'template'
                          ? 'bg-background shadow-sm font-medium'
                          : 'hover:bg-background/50'
                      }`}
                    >
                      📋 From Template
                    </button>
                  </div>

                  {/* Custom Parameter Form */}
                  {parameterSource === 'custom' && (
                    <div className="space-y-3">
                      <div className="grid grid-cols-2 gap-3">
                        <div>
                          <Label className="text-sm">Parameter Name *</Label>
                          <Input
                            value={newParamName}
                            onChange={(e) => setNewParamName(e.target.value)}
                            placeholder="my_parameter"
                            className="mt-1 font-mono"
                          />
                        </div>
                        <div>
                          <Label className="text-sm">Type</Label>
                          <Select value={newParamType} onValueChange={setNewParamType}>
                            <SelectTrigger className="mt-1">
                              <SelectValue />
                            </SelectTrigger>
                            <SelectContent>
                              <SelectItem value="string">String</SelectItem>
                              <SelectItem value="number">Number</SelectItem>
                              <SelectItem value="integer">Integer</SelectItem>
                              <SelectItem value="boolean">Boolean</SelectItem>
                              <SelectItem value="array">Array</SelectItem>
                              <SelectItem value="object">Object</SelectItem>
                            </SelectContent>
                          </Select>
                        </div>
                      </div>
                      <div>
                        <Label className="text-sm">Description</Label>
                        <Input
                          value={newParamDescription}
                          onChange={(e) => setNewParamDescription(e.target.value)}
                          placeholder="Description of this parameter..."
                          className="mt-1"
                        />
                      </div>
                      <div>
                        <Label className="text-sm">Default Value (Optional)</Label>
                        <Input
                          value={newParamDefault}
                          onChange={(e) => setNewParamDefault(e.target.value)}
                          placeholder="Default value..."
                          className="mt-1"
                        />
                      </div>
                      <div className="flex items-center gap-2">
                        <Checkbox
                          id="new-param-required"
                          checked={newParamRequired}
                          onCheckedChange={setNewParamRequired}
                        />
                        <Label htmlFor="new-param-required" className="text-sm cursor-pointer">
                          Required parameter
                        </Label>
                      </div>
                      <div className="flex justify-end gap-2">
                        <Button
                          type="button"
                          variant="outline"
                          size="sm"
                          onClick={resetNewParameterForm}
                        >
                          Cancel
                        </Button>
                        <Button
                          type="button"
                          size="sm"
                          onClick={addCustomParameter}
                          className="gap-2"
                        >
                          <Plus className="h-4 w-4" />
                          Add Custom Parameter
                        </Button>
                      </div>
                    </div>
                  )}

                  {/* Template-Based Parameter Form */}
                  {parameterSource === 'template' && (
                    <div className="space-y-3">
                      <div>
                        <Label className="text-sm">Select Template *</Label>
                        {isLoadingTemplates ? (
                          <div className="flex items-center gap-2 p-2 border rounded-lg mt-1">
                            <Loader2 className="w-4 h-4 animate-spin" />
                            <span className="text-sm text-muted-foreground">Loading templates...</span>
                          </div>
                        ) : (
                          <Select
                            value={selectedTemplateId?.toString() || ''}
                            onValueChange={(value) => {
                              const templateId = parseInt(value);
                              setSelectedTemplateId(templateId);
                              setSelectedPropertyKey('');
                              loadPropertiesForTemplate(templateId);
                            }}
                          >
                            <SelectTrigger className="mt-1">
                              <SelectValue placeholder="Choose a template..." />
                            </SelectTrigger>
                            <SelectContent>
                              {templates.map((template) => (
                                <SelectItem key={template.id} value={template.id.toString()}>
                                  {template.name}
                                </SelectItem>
                              ))}
                            </SelectContent>
                          </Select>
                        )}
                      </div>

                      {selectedTemplateId && (
                        <div>
                          <Label className="text-sm">Select Property *</Label>
                          {isLoadingProperties.has(selectedTemplateId) ? (
                            <div className="flex items-center gap-2 p-2 border rounded-lg mt-1">
                              <Loader2 className="w-4 h-4 animate-spin" />
                              <span className="text-sm text-muted-foreground">Loading properties...</span>
                            </div>
                          ) : (
                            <Select
                              value={selectedPropertyKey}
                              onValueChange={(value) => {
                                setSelectedPropertyKey(value);
                                const properties = propertiesByTemplate.get(selectedTemplateId) || [];
                                const property = properties.find((p: any) => p.key === value);
                                if (property) {
                                  setNewParamName(value.toLowerCase().replace(/\s+/g, '_'));
                                  setNewParamDescription(property.description || '');
                                  setNewParamType(property.type || 'string');
                                }
                              }}
                            >
                              <SelectTrigger className="mt-1">
                                <SelectValue placeholder="Choose a property..." />
                              </SelectTrigger>
                              <SelectContent>
                                {(propertiesByTemplate.get(selectedTemplateId) || []).map((property: any) => (
                                  <SelectItem key={property.key} value={property.key}>
                                    {property.key}
                                  </SelectItem>
                                ))}
                              </SelectContent>
                            </Select>
                          )}
                        </div>
                      )}

                      {selectedPropertyKey && (
                        <>
                          <div className="grid grid-cols-2 gap-3">
                            <div>
                              <Label className="text-sm">Parameter Name</Label>
                              <Input
                                value={newParamName}
                                onChange={(e) => setNewParamName(e.target.value)}
                                placeholder="my_parameter"
                                className="mt-1 font-mono"
                              />
                              <p className="text-xs text-muted-foreground mt-1">
                                Leave blank to auto-generate
                              </p>
                            </div>
                            <div>
                              <Label className="text-sm">Type</Label>
                              <Select value={newParamType} onValueChange={setNewParamType}>
                                <SelectTrigger className="mt-1">
                                  <SelectValue />
                                </SelectTrigger>
                                <SelectContent>
                                  <SelectItem value="string">String</SelectItem>
                                  <SelectItem value="number">Number</SelectItem>
                                  <SelectItem value="integer">Integer</SelectItem>
                                  <SelectItem value="boolean">Boolean</SelectItem>
                                  <SelectItem value="array">Array</SelectItem>
                                  <SelectItem value="object">Object</SelectItem>
                                </SelectContent>
                              </Select>
                            </div>
                          </div>
                          <div>
                            <Label className="text-sm">Description</Label>
                            <Input
                              value={newParamDescription}
                              onChange={(e) => setNewParamDescription(e.target.value)}
                              placeholder="Description..."
                              className="mt-1"
                            />
                          </div>
                          <div>
                            <Label className="text-sm">Default Value (Optional)</Label>
                            <Input
                              value={newParamDefault}
                              onChange={(e) => setNewParamDefault(e.target.value)}
                              placeholder="Default value..."
                              className="mt-1"
                            />
                          </div>
                          <div className="flex items-center gap-2">
                            <Checkbox
                              id="template-param-required"
                              checked={newParamRequired}
                              onCheckedChange={setNewParamRequired}
                            />
                            <Label htmlFor="template-param-required" className="text-sm cursor-pointer">
                              Required parameter
                            </Label>
                          </div>
                          <div className="flex justify-end gap-2">
                            <Button
                              type="button"
                              variant="outline"
                              size="sm"
                              onClick={resetNewParameterForm}
                            >
                              Cancel
                            </Button>
                            <Button
                              type="button"
                              size="sm"
                              onClick={addTemplateParameter}
                              className="gap-2"
                            >
                              <Plus className="h-4 w-4" />
                              Add Template Parameter
                            </Button>
                          </div>
                        </>
                      )}
                    </div>
                  )}
                </div>
              )}

              {/* Discovered Parameters Section */}
              {isDiscovering ? (
                <div className="flex items-center gap-2 p-4 border border-dashed rounded-lg text-sm text-muted-foreground">
                  <Loader2 className="w-4 h-4 animate-spin" />
                  Discovering parameters from nodes...
                </div>
              ) : groupedDiscovered.size > 0 ? (
                <div className="border rounded-lg p-4 bg-muted/20">
                  <Label className="text-sm font-semibold mb-2 block">Available Node Parameters</Label>
                  <p className="text-xs text-muted-foreground mb-3">
                    Click to add parameters from your workflow nodes:
                  </p>
                  <div className="flex flex-wrap gap-2">
                    {Array.from(groupedDiscovered.entries()).map(([key, params]) => {
                      const isAdded = parameters.some(p =>
                        isCustomParameter(p) && p.source_property === key
                      );
                      return (
                        <Button
                          key={key}
                          type="button"
                          variant={isAdded ? "secondary" : "outline"}
                          size="sm"
                          onClick={() => !isAdded && addParameter(params[0])}
                          disabled={isAdded}
                          className="gap-2"
                        >
                          {isAdded && <span className="text-green-500">✓</span>}
                          {key}
                          <span className="text-xs text-muted-foreground">
                            ({params.length} node{params.length > 1 ? 's' : ''})
                          </span>
                        </Button>
                      );
                    })}
                  </div>
                </div>
              ) : null}

              {/* Parameters List */}
              {parameters.length === 0 ? (
                <div className="text-sm text-muted-foreground text-center py-8 border border-dashed rounded-lg">
                  No parameters defined. Add parameters from discovered node parameters or create custom ones.
                </div>
              ) : (
                <div className="space-y-3">
                  {parameters.map((param, index) => (
                    <div key={index} className="border rounded-lg p-4 bg-background space-y-3">
                      <div className="grid grid-cols-[2fr_1.5fr_120px_80px_40px] gap-2 items-start">
                        <div>
                          <Label className="text-xs text-muted-foreground">Parameter Name</Label>
                          <Input
                            value={param.name}
                            onChange={(e) => updateParameter(index, 'name', e.target.value)}
                            placeholder="e.g., project_title"
                            className="h-9 text-sm font-mono mt-1"
                          />
                        </div>

                        <div>
                          <Label className="text-xs text-muted-foreground">Description</Label>
                          <Input
                            value={param.description}
                            onChange={(e) => updateParameter(index, 'description', e.target.value)}
                            placeholder="Description..."
                            className="h-9 text-sm mt-1"
                          />
                        </div>

                        <div>
                          <Label className="text-xs text-muted-foreground">Type</Label>
                          <Select
                            value={param.type}
                            onValueChange={(value) => updateParameter(index, 'type', value)}
                          >
                            <SelectTrigger className="h-9 text-sm mt-1">
                              <SelectValue />
                            </SelectTrigger>
                            <SelectContent>
                              <SelectItem value="string">String</SelectItem>
                              <SelectItem value="number">Number</SelectItem>
                              <SelectItem value="integer">Integer</SelectItem>
                              <SelectItem value="boolean">Boolean</SelectItem>
                              <SelectItem value="array">Array</SelectItem>
                              <SelectItem value="object">Object</SelectItem>
                            </SelectContent>
                          </Select>
                        </div>

                        <div>
                          <Label className="text-xs text-muted-foreground">Required</Label>
                          <div className="flex items-center justify-center h-9 mt-1">
                            <Checkbox
                              checked={param.required}
                              onCheckedChange={(checked) => updateParameter(index, 'required', checked)}
                            />
                          </div>
                        </div>

                        <div className="flex items-end h-full pb-1">
                          <Button
                            type="button"
                            variant="ghost"
                            size="icon"
                            onClick={() => removeParameter(index)}
                            className="h-9 w-9 text-destructive hover:text-destructive hover:bg-destructive/10"
                          >
                            <Trash2 className="h-4 w-4" />
                          </Button>
                        </div>
                      </div>

                      {/* Show source information if available */}
                      {isCustomParameter(param) && param.source_node && param.source_property && (
                        <div className="text-xs text-muted-foreground bg-muted/30 rounded px-2 py-1">
                          Source: Node "{nodes.find(n => n.id === param.source_node)?.data.label || param.source_node}" → Property "{param.source_property}"
                        </div>
                      )}
                      {isTemplateParameter(param) && (
                        <div className="text-xs text-muted-foreground bg-muted/30 rounded px-2 py-1 flex items-center gap-2">
                          <span className="font-semibold">📋 Template:</span>
                          <span>{param.template_name} → {param.property_key}</span>
                        </div>
                      )}
                    </div>
                  ))}
                </div>
              )}
            </div>
          </div>
        </div>

        {/* Footer */}
        <div className="sticky bottom-0 bg-background p-6 border-t flex items-center justify-end gap-3">
          <Button variant="outline" onClick={onClose} disabled={isSaving}>
            Cancel
          </Button>
          <Button onClick={handleSave} disabled={isSaving} className="gap-2">
            {isSaving ? (
              <>
                <Loader2 className="h-4 w-4 animate-spin" />
                Saving...
              </>
            ) : (
              <>
                <Save className="h-4 w-4" />
                Save Settings
              </>
            )}
          </Button>
        </div>
      </Card>
    </div>,
    document.body
  );
}
